#!/usr/bin/python
#
#   Aug/2008: Javier Fuchs                                    |\_/|   
#             Phone (+54 2944) 525173                        /     \  
#             http://southfox.servehttp.com                 /_.~ ~,_\ 
#                                                              \@/    
import cgi;
import os;
import sys;
import time;
import cgitb; cgitb.enable();

import libconfig;

def main():
    libconfig.starthtmlhead();
    libconfig.pagecss();
    print '  <META name="DESCRIPTION" content="Javier Fuchs: C++">';
    print '';
    print '  <TITLE>Javier Fuchs: C++</TITLE>';
    print '';
    print '<STYLE type="text/css">';
    print ' span.c2 {font-size: 80%}';
    print ' div.c1 {text-align: center}';
    print '</STYLE>';
    print '</HEAD>';
    print '';
    print '<BODY>';
    print '  <HR>';
    print '';
    print '  <DIV class="c1">';
    print '    <H1>C++</H1>';
    print '  </DIV><BR>';
    print '  The C++ programming language was invented by Bjarne Stroustrup in 1980 while he was building a distributed computing system. He based it upon the C programming language which had been invented in';
    print '  1972 by Dennis Ritchie at Bell Labs. The name C was used because the language was a successor to a language named BCPL (Basic Combined Programming Language) which was invented by Martin Richards in';
    print '  1967. The name C++ was used to suggest an incremented C. Stroustrup incremented C by adding classes. Indeed, he first named "C with Classes". The classes feature, which facilitates object-oriented';
    print '  programming, came from the Simula programming language, developed in the early 1960s.';
    print '';
    print '  <P>In 1998, the C++ programming language was standardized by the International Standards Organization (ISO) and by the American National Standards Institute (ANSI). This new standard includes the';
    print '  Standard Template Library (STL) developed originally by Alexander Stepanov in 1979. The term "Standard C++" refers to this standardized version of the language.</P>';
    print '';
    print '  <H2>Tips &amp; Tricks</H2>';
    print '';
    print '  <UL>';
    print '    <LI><A href="cgipy/cpp.py#hello-world">Hello World!</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#cuadratica">The Quadratic Formula</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#horner">Horner Method for polynomials</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#pascal">Pascal: binomial coefficients</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#stl-container">STL: Container Adaptors</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#stl-pair">STL: pair</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#stl-map">STL: map</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#stl-hash_map">STL: hash_map</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#stl-hash">STL: hash</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#hash-table">Hash Table</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#tree1">Tree: Binary tree of integers.</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#tree2">Tree: Binary tree using templates</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#tree3">Tree: n-order tree</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#entrada-salida">Input/output streams</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#mydate">Date and Time under Unix/Linux</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#myvector">Implementation of a STL Vector</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#mystring">Implementation of a STL String</A></LI>';
    print '';
    print '    <LI><A href="cgipy/cpp.py#myenv">Getting environment variables</A></LI>';
    print '  </UL>';
    print '  <HR>';
    print '';
    print '  <H2><A name="hello-world" id="hello-world">Hello World!</A></H2>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="Source code hello.cpp" href="cpp/hello.cpp.html">hello.cpp</A></TD>';
    print '';
    print '      <TD>Hello world.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="cuadratica" id="cuadratica">The Quadratic Formula</A></H2>Implementation of the resolution of the quadratic formula:<B>ax<SUP>2</SUP> + bx + c = 0</B>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="Source code cuadratica.cpp" href="cpp/cuadratica.cpp.html">cuadratica.cpp</A></TD>';
    print '';
    print '      <TD>Quadratic Formula.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="horner" id="horner">Horner Method for polynomials</A></H2>';
    print '';
    print '  <P>To evaluate polynomials of the form:<BR>';
    print '  <B>p(x) = a<SUB>0</SUB> + a<SUB>1</SUB>.x<SUP>1</SUP> + a<SUB>2</SUB>.x<SUP>2</SUP> + ... + a<SUB>n</SUB>.x<SUP>n</SUP></B></P>';
    print '';
    print '  <P>but, using...<BR>';
    print '  <B>p(x) = a<SUB>0</SUB> + x(a<SUB>1</SUB> + x(a<SUB>2</SUB> + ... + x(a<SUB>n</SUB>)...))</B></P>';
    print '';
    print '  <P>For example:<BR>';
    print '  <B>p(x) = 5 - 8x + 4x<SUP>3</SUP></B></P>';
    print '';
    print '  <P>Takes this form: <B>p(x) = 5 - x(8 + x(0 + x(4)))</B></P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="Source code horner.cpp" href="cpp/horner.cpp.html">horner.cpp</A></TD>';
    print '';
    print '      <TD>Horner.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="pascal" id="pascal">Pascal: binomial coefficients</A></H2>Pascal Triangle.';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="Source code triangulopascal.cpp" href="cpp/triangulopascal.cpp.html">triangulopascal.cpp</A></TD>';
    print '';
    print '      <TD>Prints a Pascal Triangle of order 12.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="stl-container" id="stl-container">STL: Container Adaptors</A></H2>The classes:';
    print '';
    print '  <UL>';
    print '    <LI>stack</LI>';
    print '';
    print '    <LI>queue</LI>';
    print '';
    print '    <LI>priority_queue</LI>';
    print '  </UL>are not containers but rather are classes that provide a limited subset of container operations.';
    print '';
    print '  <P>These classes are "adaptors" because they are implemented in terms of underlying container.</P>';
    print '';
    print '  <P>Stacks, queues, and priority queues are familiar data structures, but one aspect of these container adaptor"s interface might seem unfamiliar.</P>';
    print '';
    print '  <P>All three of these classes have a member function "pop", which removes the top element, an that member function has no return value.</P>';
    print '';
    print '  <H3>priority_queue</H3>priority_queue&lt;T,Sequence,Compare&gt;';
    print '';
    print '  <P>A priority_queue is an adaptor that provides a restricted subset of Container functionality.</P>';
    print '';
    print '  <P>It provides insertion of elements, and inspection and removal of the top element. There is no mechanism for modifying any of the priority_queue"s elements, of for iterating through them.</P>';
    print '';
    print '  <P>A priority_queue is organized such that the top element is always the largest, where the function object Compare defines the ordering. This is the reason that priority_queue does not provide';
    print '  individual access to its elements. The fact that the largest element is the top is a class invariant.</P>';
    print '';
    print '  <P>Since priority_queue is a container adaptor, it is implemented on top of some underlying container type. By default that underlying type is "vector", but different type may be selected';
    print '  explicitly.</P>';
    print '';
    print '  <P>Prioriry queues are a standard data structure and can be implemented in many different ways. The class priority_queue is typically implemented as a help, where the heap condition is maintained';
    print '  using the algorithms</P>';
    print '';
    print '  <UL>';
    print '    <LI>make_heap</LI>';
    print '';
    print '    <LI>push_heap</LI>';
    print '';
    print '    <LI>pop_heap</LI>';
    print '  </UL>priority_queue are a standard data structure.';
    print '';
    print '  <P>priority_queue = BIFO: best in first out (the best one in comes out first). That means that each element is assigned a priority number, and the element with the highest priority comes out';
    print '  first.<BR>';
    print '  access: insertion of elements, and inspection and removal of the top element.<BR>';
    print '  No iterators</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="priority_queue.cpp" href="cpp/stl.priority_queue.cpp.html">priority_queue.cpp</A></TD>';
    print '';
    print '      <TD>Test.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '';
    print '  <H3>queue</H3>queue&lt;T,Sequence&gt;';
    print '';
    print '  <P>A queue is an adaptor that provides a restricted subset of Container functionality. It is a "first in first out" (FIFO) data structure. That is, elements are added to the back of the queue and';
    print '  may be removed from the front; Q.front() is the element that was added to the queue least recently.</P>';
    print '';
    print '  <P>There is no way to access any of a queue"s elements except por the ones at the front and the back; queue has no iterators. This restriction is the only reason that stack exists, since any Front';
    print '  Insertion Sequence or Back Insertion<BR>';
    print '  Sequence can already be used as a queue.<BR>';
    print '  For example, "deque" and "list" have member functions:</P>';
    print '';
    print '  <UL>';
    print '    <LI>front()</LI>';
    print '';
    print '    <LI>back()</LI>';
    print '';
    print '    <LI>push_front()</LI>';
    print '';
    print '    <LI>push_back()</LI>';
    print '';
    print '    <LI>pop_front()</LI>';
    print '';
    print '    <LI>pop_back()</LI>';
    print '  </UL><BR>';
    print '  The only reason to use the container adaptor "queue", rather than the container "deque;, is to make it clear that you are performing queue operations only and no other operations.';
    print '';
    print '  <P>Since queue is a container adaptor, it is implemented on top of some underlying container type. By default that underlying type is "deque", but different type may be selected explicitly.</P>';
    print '';
    print '  <P>queue are a standard data structure.<BR>';
    print '  queue = FIFO: first in first out<BR>';
    print '  access: element at the front -&gt; front(), and the back -&gt; back()<BR>';
    print '  No iterators</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="queue.cpp" href="cpp/stl.queue.cpp.html">queue.cpp</A></TD>';
    print '';
    print '      <TD>Test.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '';
    print '  <H3>stack</H3>stack&lt;T,Sequence&gt;';
    print '';
    print '  <P>A stack is an adaptor that provides a restricted subset of Container functionality. It provides insertion, removal, and inspection of the element at the top of the stack. It is a "last in first';
    print '  out" (LIFO) data structure. The element at the top of a stack is the one that was most recently added.</P>';
    print '';
    print '  <P>There is no way to access any of a stack"s elements except por the top element; stack does not allow iteration through its elements. This restriction is the only reason that stack exists, since';
    print '  any Front Insertion Sequence or Back Insertion Sequence can already be used as a stack.<BR>';
    print '  In the case of "vector", for example, the stack operations are the member functions back, push_back and pop_back.<BR>';
    print '  The only reason to use the container adaptor "stack", instead of directly using a Sequence, is to make it clear that you are performing stack operations only.</P>';
    print '';
    print '  <P>Since stack is a container adaptor, it is implemented on top of some underlying container type. By default that underlying type is "deque", but different type may be selected explicitly.</P>';
    print '';
    print '  <P>stack are a standard data structure.<BR>';
    print '  stack = LIFO: last in first out<BR>';
    print '  access: element at the top, most recently added -&gt; top()<BR>';
    print '  No iterators</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="stack.cpp" href="cpp/stl.stack.cpp.html">stack.cpp</A></TD>';
    print '';
    print '      <TD>Test.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="stl-pair" id="stl-pair">STL: pair</A></H2>';
    print '';
    print '  <H3>pair</H3>pair&lt;T1,T2&gt;';
    print '';
    print '  <P>The class pair&lt;T1,T2&gt; is a heterogeneous pair. It holds one object of type T1 and one of type T2. A "pair" is much like a Container, in that it "owns" its elements (they are destroyed when';
    print '  the "pair" itself is destroyed), but it is not actually a model of Container because it does not support the standard methods (such as iterators) for accessing Container elements.</P>';
    print '';
    print '  <P>Functions that need to return two values often return a "pair"</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="pair.cpp" href="cpp/stl.pair.cpp.html">pair.cpp</A></TD>';
    print '';
    print '      <TD>Test.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="stl-map" id="stl-map">STL: map</A></H2>';
    print '';
    print '  <H3>map</H3>map&lt;Key, T, Compare, Allocator&gt;';
    print '';
    print '  <P>A "map" is a Sorted Associative Container that associates objects of type "Key" with objects of type "T". It is a Pair Associative Container, meaning that its value type is "pair&lt;const Key,';
    print '  T&gt;". It is also a Unique Associative Container, meaning that no two elements have the same key.</P>';
    print '';
    print '  <P>The containers "map" and "set" are very similar. The main difference is that "set" is a Simple Associative Container (its value type is the same as its key type) while "map" is a Pair';
    print '  Associative Container (its value type is its key type plus some other associated piece of data.)</P>';
    print '';
    print '  <P>One consequence of this difference is that "set" does not distinguish between "iterator" and "const_iterator", but "map" does.</P>';
    print '';
    print '  <P>Like "list", "map" has the important property that inserting a new element does not invalidate iterators that point to existing elements. Erasing an element from a "map" does not invalidate any';
    print '  iterators either, except, of course, for iterators that point to the element that is being erased.</P>';
    print '';
    print '  <H4>Examples:</H4>Because "map" associates objects of one type with objects of another, you can use a "map" as an associative array.';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="map1.cpp" href="cpp/stl.map1.cpp.html">map1.cpp</A></TD>';
    print '';
    print '      <TD>Usando map como un "<I>associative array</I>"</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="map2.cpp" href="cpp/stl.map2.cpp.html">map2.cpp</A></TD>';
    print '';
    print '      <TD>Usando map con <B>make_pair</B></TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="stl-hash_map" id="stl-hash_map">STL: hash_map</A></H2>';
    print '';
    print '  <H3>hash_map</H3>hash_map&lt;Key, T, HashFun, EqualKey, Allocator&gt;';
    print '';
    print '  <P>A hash_map is a Hashed Associated Container that associates objects of type Key with objects of type T.</P>';
    print '';
    print '  <P>It is a Pair Associative Container, meaning that its value type is pair&lt;const Key, T&gt;</P>';
    print '';
    print '  <P>It is also a Unique Associative Container, meaning that no two elements have keys that compare equal using EqualKey.</P>';
    print '';
    print '  <P>Looking up an element in a hash_map by its key is efficient, so hash_map is useful for "dictionaries", or associative arrays, where an object of type Key is associated with an object of type T';
    print '  but where the order of elements is irrelevant. If it is important for the elements to be arranged in some particular order, however, "map" is more appropiate.</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="hash_map.cpp" href="cpp/stl.hash_map.cpp.html">hash_map.cpp</A></TD>';
    print '';
    print '      <TD>Test of hash_map</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="stl-hash" id="stl-hash">STL: hash</A></H2>';
    print '';
    print '  <H3>Hash Function</H3>A Hash Function is a Unary Function that is used by Hashed Associative Containers. It takes a single arguemnt, and maps that argument to a result of type "size_t". A Hash';
    print '  Function must be deterministic, meaning that the return value must depend only on the argument and that equal arguments must yield equals results.';
    print '';
    print '  <P>The performance of a Hashed Associative Container depends crucially on its hash function.</P>';
    print '';
    print '  <P>It is important:</P>';
    print '';
    print '  <OL>';
    print '    <LI>for a Hash Function to minimize collisions, where a collision is defined as two different arguments that hash to the same value.</LI>';
    print '';
    print '    <LI>for the distribution of hash values to be uniform. The probability that a Hash Function returns any particular value of type "size_t" should be roughly the same as the probability that it';
    print '    returns any other value.</LI>';
    print '';
    print '    <LI>Finaly, for the Hash Function to be fast.</LI>';
    print '  </OL>There is naturally some tension among these three goals.';
    print '';
    print '  <P>No one hash function is best for every application.</P>';
    print '';
    print '  <P>Note also that a Hash Function does not know the number of "buckets" that the Hashed Associative Container will eventually use.<BR>';
    print '  A Hash Function is responsible only for mapping its argumetn to a number -posibly a very large number. It is the Hashed Associative Container"s reponsibility to turn that large number into the';
    print '  address of a particular bucket.</P>';
    print '';
    print '  <P>bucket: cubo (lleno), balde (lleno)</P>';
    print '';
    print '  <H3>hash</H3>';
    print '';
    print '  <P>The class hash&lt;T&gt; is a Hash Function. It is used as the default hash function by all of the Hashed Associative Containers that are included in the STL.</P>';
    print '';
    print '  <P>The template hash&lt;T&gt; is only defines for template arguments of type:</P>';
    print '';
    print '  <UL>';
    print '    <LI>char*</LI>';
    print '';
    print '    <LI>const char*</LI>';
    print '';
    print '    <LI>string</LI>';
    print '';
    print '    <LI>built-in integral types:<BR>';
    print '';
    print '      <UL>';
    print '        <LI>char</LI>';
    print '';
    print '        <LI>signed char</LI>';
    print '';
    print '        <LI>unsigned char</LI>';
    print '';
    print '        <LI>short</LI>';
    print '';
    print '        <LI>unsigned short</LI>';
    print '';
    print '        <LI>int</LI>';
    print '';
    print '        <LI>unsigned int</LI>';
    print '';
    print '        <LI>long</LI>';
    print '';
    print '        <LI>unsigned long</LI>';
    print '      </UL>';
    print '    </LI>';
    print '  </UL>';
    print '';
    print '  <P>Members:<BR>';
    print '  size_t hash::operator()(const T&amp; x) const<BR>';
    print '  Returns x"s hash value.</P>';
    print '';
    print '  <P>If you need a Hash Function with a different argument type, you must either provide your own template specialization or else write a new Hash Function class.</P>';
    print '';
    print '  <H4>Defined in:</H4>';
    print '';
    print '  <UL>';
    print '    <LI>&lt;hash_set&gt;</LI>';
    print '';
    print '    <LI>&lt;hash_map&gt;</LI>';
    print '  </UL>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="hash.cpp" href="cpp/stl.hash.cpp.html">hash.cpp</A></TD>';
    print '';
    print '      <TD>hash</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="hash-table" id="hash-table">Hash Table</A></H2>';
    print '';
    print '  <P>Source code:<BR></P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="HashTable.h" href="cpp/hash.HashTable.h.html">HashTable.h</A></TD>';
    print '';
    print '      <TD>Hash Table</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="HashTableTestDriver.cpp" href="cpp/hash.HashTableTestDriver.cpp.html">HashTableTestDriver.cpp</A><BR></TD>';
    print '';
    print '      <TD>Test</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="makefile" href="cpp/hash.makefile.html">makefile</A><BR></TD>';
    print '';
    print '      <TD>makefile</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="tree1" id="tree1">Tree: Binary tree of integers.</A></H2>';
    print '';
    print '  <P>Source code:<BR></P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeNode.h" href="cpp/tree1.TreeNode.h.html">TreeNode.h</A></TD>';
    print '';
    print '      <TD>class TreeNode</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeNode.cpp" href="cpp/tree1.TreeNode.cpp.html">TreeNode.cpp</A></TD>';
    print '';
    print '      <TD>Test</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="makefile" href="cpp/tree1.makefile.html">makefile</A><BR></TD>';
    print '';
    print '      <TD>makefile</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="tree2" id="tree2">Tree: Binary tree using templates</A></H2>';
    print '';
    print '  <P>Source code:<BR></P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeNode.h" href="cpp/tree2.TreeNode.h.html">TreeNode.h</A></TD>';
    print '';
    print '      <TD>template-class TreeNode</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeNodeString.cpp" href="cpp/tree2.TreeNodeString.cpp.html">TreeNodeString.cpp</A><BR></TD>';
    print '';
    print '      <TD>Binary tree using strings (<B>string</B>).</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeNode.cpp" href="cpp/tree2.TreeNode.cpp.html">TreeNode.cpp</A><BR></TD>';
    print '';
    print '      <TD>Binary tree using integers (<B>int</B>).</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="makefile" href="cpp/tree2.makefile.html">makefile</A><BR></TD>';
    print '';
    print '      <TD>makefile</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="tree3" id="tree3">Tree: Arbol n-ario</A></H2>A <I>tree</I> is a nonlinear container that models a hierarchical relationship in which all but one element has a unique predecessor';
    print '  (parent) but may have many successors (children). The unique parentles element is called the <I>root</I> of the tree.';
    print '  <PRE>';
    print '';
    print '                          [A]                    ';
    print '                           |                  ';
    print '         +-----------------+-----------------+';
    print '         |                 |                 |';
    print '        [B]               [C]               [D]';
    print '         |                 |                     ';
    print '         |         +-------+-------+             ';
    print '         |         |       |       |             ';
    print '        [E]       [F]     [G]     [H]            ';
    print '         |         |               |             ';
    print '     +---+---+     |       +---+---+---+---+     ';
    print '     |       |     |       |   |   |   |   |     ';
    print '    [I]     [J]   [K]     [L] [M] [N] [O] [P]    ';
    print '</PRE>';
    print '';
    print '  <P>En esta relaci&#243;n todos menos un elemento tienen un &#250;nico predecesor, el padre (parent) y todos pueden tener muchos sucesores: hijos (children: B-C-D-E-F-G-H-I-J-K-L-M-N-O-P).</P>';
    print '';
    print '  <P>El &#250;nico elemento que no tiene padre es llamado ra&#237;z (root: A).</P>';
    print '';
    print '  <P>La estructura de directorios y archivos de una computadora es un ejemplo de un tree.</P>';
    print '';
    print '  <H4>Terminology:</H4>';
    print '';
    print '  <TABLE>';
    print '    <TR>';
    print '      <TD>nodes</TD>';
    print '';
    print '      <TD>Elements of a tree, every node has a unique path connecting it to the root of the tree.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>path</TD>';
    print '';
    print '      <TD>is a sequence of adjacent elements.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>length</TD>';
    print '';
    print '      <TD>The <I>lenght</I> of a path is the number of its adjacent connections, which is one less than the number of nodes that it connects.<BR>';
    print '      Ex.: the path (M,H,C,A) connecting node <B>M</B> to the root node <B>A</B> hast lenght 3<BR>';
    print '      length = 3</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>depth</TD>';
    print '';
    print '      <TD>The <I>depth</I> of a node is the lenght of its path up the root.<BR>';
    print '      Ex. the node "E" has depth = 2<BR>';
    print '      the node "M" has depth = 3<BR></TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>level</TD>';
    print '';
    print '      <TD>The <I>level</I> of a tree, are all the nodes at a given depth<BR>';
    print '      Ex. In the tree with root <B>A</B> level 2 consits of the set of nodes {E,F,G,H}<BR>';
    print '      level = 2</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>height</TD>';
    print '';
    print '      <TD>The <I>height</I> of a tree is the greatest depth among all of its nodes.<BR>';
    print '      Ex.: In the tree shown above has height 3<BR>';
    print '      The tree whose root is its only node is called a <I>singleton tree</I>; its height is 0.<BR>';
    print '      The tree with 0 nodes is called the empty tree; its height is defined to be -1.<BR></TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>ancestors</TD>';
    print '';
    print '      <TD>For each node "x", The notation: p(x), denote the path from "x" to the root of the tree.<BR>';
    print '      Ex.: p(M) = {M,H,C,A}<BR>';
    print '      Except for <B>x</B> itself, the nodes in <B>p(x)</B> are called the <I>ancestors</I> of <B>x</B>. In the case of "M", the ancestors are {H,C,A}<BR>';
    print '      The adjacent ancestor of a node is called its <I>parent</I> node.<BR>';
    print '      The adjacent descendants of a node are called its <I>child</I> nodes.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>leaf nodes</TD>';
    print '';
    print '      <TD>Nodes that have no children are called <I>leaf</I> nodes.<BR>';
    print '      Ex. D,M</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>internal nodes</TD>';
    print '';
    print '      <TD>Nonleaf nodes are called <I>internal</I> nodes.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>subtree</TD>';
    print '';
    print '      <TD>For each node <I>y</I> in a tree, the set consisting of <I>y</I> and all its descendants form the "subtree" rooted at <I>y</I>.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>path length</TD>';
    print '';
    print '      <TD>the <I>path lenght</I> of a tree is the sum of the lengths of all paths from its root.<BR>';
    print '      Ex.: the path length of the tree shown above is<BR>';
    print '      1*3 + 2*4 + 3*8 = 35</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>degree</TD>';
    print '';
    print '      <TD>The <I>degree</I> of a node is the number of its children.<BR>';
    print '      Ex. degree(B) = 1<BR>';
    print '      degree(D) = 0<BR>';
    print '      degree(H) = 5</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD>full tree</TD>';
    print '';
    print '      <TD>A tree is said to be <I>full</I> if all of its internal nodes have the same degree and all of its leaves are at the same level.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '';
    print '  <P><B>Theorem</B>: a "full tree" of degree "d" and height "h" has :<B>(d^<SUP>(h+1)</SUP> - 1) / (d - 1)</B> nodes</P>';
    print '';
    print '  <P>Source code:<BR></P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="Tree.h" href="cpp/tree3.Tree.h.html">Tree.h</A></TD>';
    print '';
    print '      <TD>Interface for the container: Tree</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="Tree.cpp" href="cpp/tree3.Tree.cpp.html">Tree.cpp</A><BR></TD>';
    print '';
    print '      <TD>Class Tree (implementation)</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="TreeTest.cpp" href="cpp/tree3.TreeTest.cpp.html">TreeTest.cpp</A><BR></TD>';
    print '';
    print '      <TD>Test: building a tree</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="makefile" href="cpp/tree3.makefile.html">makefile</A><BR></TD>';
    print '';
    print '      <TD>makefile</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="entrada-salida" id="entrada-salida">Input/output streams</A></H2>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="myLog.h" href="cpp/myLog.h.html">myLog.h</A></TD>';
    print '';
    print '      <TD>Declaration of myLog()</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="myLog.cpp" href="cpp/myLog.cpp.html">myLog.cpp</A></TD>';
    print '';
    print '      <TD>Test case and implementation of myLog().</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="mydate" id="mydate">Date and Time under Unix/Linux</A></H2>This class obtains the date/time/centesimal of the operating system in diferent formats.';
    print '';
    print '  <P>The formates are the same of the function <B>strftime()</B>.</P>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="myDate.h" href="cpp/myDate.h.html">myDate.h</A></TD>';
    print '';
    print '      <TD>Class.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="myvector" id="myvector">Implementation of a STL Vector</A></H2>Template-Class that help to build vectores of every type (template). It has operators for add elements, sort, print.';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="myVector.h" href="cpp/myVector.h.html">myVector.h</A></TD>';
    print '';
    print '      <TD>Template-Class</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="mystring" id="mystring">Implementation of a STL String</A></H2>';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="myString.h" href="cpp/myString.h.html">myString.h</A></TD>';
    print '';
    print '      <TD>Template-Class que permite construir strings.</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="myBlock.h" href="cpp/myBlock.h.html">myBlock.h</A></TD>';
    print '';
    print '      <TD>Template-Class</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="myStringTest.cpp" href="cpp/myStringTest.cpp.html">myStringTest.cpp</A></TD>';
    print '';
    print '      <TD>Test.</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    print '  <H2><A name="myenv" id="myenv">Getting environment variables</A></H2>Class child of <B>myString</B> for environment variables.';
    print '';
    print '  <P>Source code:</P>';
    print '';
    print '  <TABLE border="1" cellspacing="0" cellpadding="1">';
    print '    <TR>';
    print '      <TD width="20%"><A title="myEnv.h" href="cpp/myEnv.h.html">myEnv.h</A></TD>';
    print '';
    print '      <TD>Implementation</TD>';
    print '    </TR>';
    print '';
    print '    <TR>';
    print '      <TD width="20%"><A title="myEnvTest.cpp" href="cpp/myEnvTest.cpp.html">myEnvTest.cpp</A></TD>';
    print '';
    print '      <TD>Test</TD>';
    print '    </TR>';
    print '  </TABLE>';
    print '  <HR>';
    print '';
    libconfig.bottomline();
    print '</BODY>';
    print '</HTML>';

main();
